using System;
using UnityEngine;
using R3;
using Zenject;
using Project.Core.Services.Addressable;
using Project.Core.Services.Addressable.Memory;
using Project.Core.Services.Loading;

namespace Project.Core.Services.Integration
{
    /// <summary>
    /// R3 Observable integration for automatic memory management and cleanup
    /// R3 Observable интеграция для автоматического управления памятью и очистки
    /// </summary>
    public class AddressableMemoryIntegration : IInitializable, IDisposable
    {
        private readonly IAddressableService _addressableService;
        private readonly IAddressableMemoryManager _memoryManager;
        private readonly ILoadingService _loadingService;
        
        private readonly CompositeDisposable _disposables = new CompositeDisposable();
        
        /// <summary>
        /// Observable for memory pressure warnings
        /// Observable для предупреждений о давлении памяти
        /// </summary>
        public Observable<float> OnMemoryPressure => _memoryPressureSubject.AsObservable();
        private readonly Subject<float> _memoryPressureSubject = new Subject<float>();
        
        /// <summary>
        /// Observable for cleanup events
        /// Observable для событий очистки
        /// </summary>
        public Observable<int> OnMemoryCleanup => _memoryCleanupSubject.AsObservable();
        private readonly Subject<int> _memoryCleanupSubject = new Subject<int>();

        public AddressableMemoryIntegration(
            IAddressableService addressableService,
            IAddressableMemoryManager memoryManager,
            ILoadingService loadingService)
        {
            _addressableService = addressableService ?? throw new ArgumentNullException(nameof(addressableService));
            _memoryManager = memoryManager ?? throw new ArgumentNullException(nameof(memoryManager));
            _loadingService = loadingService ?? throw new ArgumentNullException(nameof(loadingService));
        }

        /// <summary>
        /// Initialize integration and setup automatic memory management
        /// Инициализировать интеграцию и настроить автоматическое управление памятью
        /// </summary>
        public void Initialize()
        {
            SetupMemoryMonitoring();
            SetupAssetTracking();
            SetupSceneChangeCleanup();
            
            Debug.Log("[AddressableMemoryIntegration] Initialized with automatic memory management");
        }

        /// <summary>
        /// Setup periodic memory monitoring
        /// Настроить периодический мониторинг памяти
        /// </summary>
        private void SetupMemoryMonitoring()
        {
            // Monitor memory every 30 seconds
            Observable.Interval(TimeSpan.FromSeconds(30))
                .Where(_ => _memoryManager != null)
                .Subscribe(_ =>
                {
                    try
                    {
                        CheckMemoryPressure();
                    }
                    catch (Exception ex)
                    {
                        Debug.LogError($"[AddressableMemoryIntegration] Memory monitoring error: {ex.Message}");
                    }
                })
                .AddTo(_disposables);
        }

        /// <summary>
        /// Setup asset tracking integration
        /// Настроить интеграцию отслеживания ресурсов
        /// </summary>
        private void SetupAssetTracking()
        {
            if (_addressableService is AddressableService service)
            {
                // Track asset loading events
                service.OnAssetLoaded
                    .Subscribe(assetInfo =>
                    {
                        try
                        {
                            var (key, loadTime, size) = assetInfo;
                            Debug.Log($"[AddressableMemoryIntegration] Asset {key} loaded: {size} bytes in {loadTime:F2}s");
                            
                            // Trigger memory check after large asset loads
                            if (size > 10 * 1024 * 1024) // 10MB threshold
                            {
                                CheckMemoryPressure();
                            }
                        }
                        catch (Exception ex)
                        {
                            Debug.LogError($"[AddressableMemoryIntegration] Asset tracking error: {ex.Message}");
                        }
                    })
                    .AddTo(_disposables);
            }
        }

        /// <summary>
        /// Setup automatic cleanup on scene changes
        /// Настроить автоматическую очистку при смене сцен
        /// </summary>
        private void SetupSceneChangeCleanup()
        {
            // Monitor scene changes and trigger cleanup
            Observable.EveryUpdate()
                .Select(_ => UnityEngine.SceneManagement.SceneManager.GetActiveScene().name)
                .DistinctUntilChanged()
                .Skip(1) // Skip initial scene
                .Subscribe(sceneName =>
                {
                    try
                    {
                        TriggerSceneChangeCleanup();
                    }
                    catch (Exception ex)
                    {
                        Debug.LogError($"[AddressableMemoryIntegration] Scene change cleanup error: {ex.Message}");
                    }
                })
                .AddTo(_disposables);
        }

        /// <summary>
        /// Check current memory pressure and trigger cleanup if needed
        /// Проверить текущее давление памяти и запустить очистку при необходимости
        /// </summary>
        private void CheckMemoryPressure()
        {
            if (_memoryManager == null) return;

            var totalMemory = _memoryManager.CurrentMemoryUsage;
            var maxMemory = 100 * 1024 * 1024; // 100MB default limit
            var pressure = totalMemory > 0 ? (float)totalMemory / maxMemory : 0f;
            
            _memoryPressureSubject.OnNext(pressure);

            // Trigger cleanup if pressure is high
            if (pressure > 0.8f) // 80% threshold
            {
                Debug.LogWarning($"[AddressableMemoryIntegration] High memory pressure detected: {pressure:P1}");
                TriggerMemoryCleanup();
            }
            else if (pressure > 0.6f) // 60% warning
            {
                Debug.Log($"[AddressableMemoryIntegration] Memory pressure elevated: {pressure:P1}");
            }
        }

        /// <summary>
        /// Trigger memory cleanup process
        /// Запустить процесс очистки памяти
        /// </summary>
        private void TriggerMemoryCleanup()
        {
            if (_memoryManager == null) return;

            try
            {
                var cleanedCount = _memoryManager.PerformAutomaticCleanup();
                
                if (cleanedCount > 0)
                {
                    _memoryCleanupSubject.OnNext(cleanedCount);
                    Debug.Log($"[AddressableMemoryIntegration] Cleaned up {cleanedCount} assets from memory");
                    
                    // Force garbage collection after cleanup
                    GC.Collect();
                    
                    // Notify loading service if cleanup happened during loading
                    if (_loadingService.IsLoading.CurrentValue)
                    {
                        _loadingService.UpdateStatus("Memory optimized");
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AddressableMemoryIntegration] Memory cleanup failed: {ex.Message}");
            }
        }

        /// <summary>
        /// Trigger cleanup on scene changes
        /// Запустить очистку при смене сцен
        /// </summary>
        private void TriggerSceneChangeCleanup()
        {
            Debug.Log("[AddressableMemoryIntegration] Scene changed, performing automatic cleanup");
            
            // Small delay to ensure scene transition is complete
            Observable.Timer(TimeSpan.FromSeconds(1f))
                .Subscribe(_ =>
                {
                    TriggerMemoryCleanup();
                    
                    // Clear any unused cached content
                    UnityEngine.Caching.ClearCache();
                    
                    Debug.Log("[AddressableMemoryIntegration] Scene change cleanup completed");
                })
                .AddTo(_disposables);
        }

        /// <summary>
        /// Manual memory cleanup trigger
        /// Ручной запуск очистки памяти
        /// </summary>
        public void ForceMemoryCleanup()
        {
            Debug.Log("[AddressableMemoryIntegration] Force memory cleanup requested");
            TriggerMemoryCleanup();
        }

        /// <summary>
        /// Get current memory usage report
        /// Получить текущий отчет об использовании памяти
        /// </summary>
        public string GetMemoryReport()
        {
            return _memoryManager?.GenerateMemoryReport() ?? "Memory manager not available";
        }

        /// <summary>
        /// Dispose resources and cleanup subscriptions
        /// Освободить ресурсы и очистить подписки
        /// </summary>
        public void Dispose()
        {
            _disposables?.Dispose();
            _memoryPressureSubject?.Dispose();
            _memoryCleanupSubject?.Dispose();
            
            Debug.Log("[AddressableMemoryIntegration] Disposed");
        }
    }
}
